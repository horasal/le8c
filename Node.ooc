RuleUsed      := static const 1<<0
RuleReached   := static const 1<<1

RuleManager: class{
	rules:= ArrayList<Rule> new()
	currentrule := 0

	add: func(name: String, defined: Bool) -> Rule {
		r := Rule new(name, rules size, defined)
		rules add(r)
		r
	}

	find: func(name: String, defined: Bool) -> Rule {
		rname := name map(|x| x == '-' ? '_' : x)
		for(r in rules){
			if(r name == rname) return r
		}
		return add(name, defined)
	}

	begin: func(count: Int){ currentrule = count }
}

Node: abstract class {
	count : static Int = 0
    id: Int = 0
	errorBlock: String
	compile: abstract func -> String
    call: abstract func -> String
	consumesInput: abstract func -> Bool
	toString: abstract func -> String
	counter: static func -> Int { 
		count += 1
		return count
	}
}

Header : class extends Node {
	text: String
	init: func(=text){ id = counter() }
	compile: func -> String { 
		"/* A recursive-descent parser generated by le8c */\n" + \
		"/* parser header */\n" + text
	}
	consumesInput: func -> Bool { false }
	toString: func -> String { "Header: " + text }
}

Rule: class extends Node {
	name: String
	variables := ArrayList<Variable> new() 
	expression : Node
	flags: Int

	init: func(=name, defined: Bool){
		r flags = defined ? RuleUsed : 0
        id = counter()
	}

	toString: func -> String { "Rule " + name }

	addVariable: func(name: String) -> Node {
		for(v in variables){ if(v name == name) return v }
		v := Variable new(name)
		variables add(v)
		v
	}

    call : func -> String{ "Rule%s()" format(name) }

	compile: func -> String {
		if(!expression) Error new("rule %s used but not defined" format(name)) throw()
		safe := expression instanceOf?(Query) || expression instanceOf?(Star)
		ret := "Rule%s: func -> Bool {\n" format(name)
		if(expression instanceOf?(Rule)) Error new("internal error #1 (%s)" format(expression as Rule name)) throw()
		ret += expression compile()
		ret + "return true\n}\n"
	}

	consumesInput: func -> Bool {
		result := false
		if(RuleReached & flags) Warning new("possible infinite left recursion in rule %s" format(this toString())) throw()
		else {
			flags = flags | RuleReached
			result = expression consumesInput()
			flags = flags & (~RuleReached)
		}
		result
	}
}

Variable: class extends Node {
	name: String
	value: Node

	init: func(=name){
        id = counter()
    }

	compile: func -> String{
    }
    access: func -> String { "variableStack[%s]" format(name) }

	toString: func -> String { "Variable " + name }
}

Name: class extends Node {
	rule, variable: Node

	init: func(=rule) {
		variable = null
		rule flags = rule flags | RuleUsed
        id = counter()
	}

    call: func -> String { "Name%d()" format(id) }

	compile: func -> String{
        ret = "Name%d: func -> Bool { if(!yyRule%s()){\n" format(id, rule name)
		if(errorBlock size > 0) ret += callErrorBlock()
		ret += "return false\n}\n"
		if(variable) ret += "yyDo(set, %d, 0, \"yySet\")\n" format(variable offset)
		ret + "true }"
	}
	consumesInput: func -> Bool { rule consumesInput() }
}

Dot: class extends Node { 
	init: func{
        id = counter()
    }
    call: func -> String{ "Dot%d()" format(id) }
	compile: func -> String{
        ret = "Dot%d: func -> Bool{\n" format(id)
        ret + "matchDot()\n}"
    }
	consumesInput: func -> Bool { true }
}

Character: class extends Node {
	value: string
	init: func(=value){
        id = counter()
    }
    call: func -> String{ "Character%d()" format(id) }
	compile: func -> String {
        ret := "Character%d: func -> Bool {\n" format(id)
        if(value[0] == '\''){
            ret += "matchChar('\\''))"
        } else {
            ret += "matchChar('%s')" format(value)
        }
        ret + "\n}\n"

	}
	consumesInput: func -> Bool { value size > 0 }
}

String: class extends Node {
	value; String
	init: func(=value){
        id = counter()
    }
    call: func -> String{ "String%d()" format(id) }
	compile: func -> String{
        ret := "String%d: func -> Bool { \n" format(id)
        ret += "matchString(\"%s\")" format(value)
        ret + "\n}\n"
    }
	consumesInput: func -> Bool { value size > 0 }
}

Class: class extends Node {
	value := ArrayList<UInt8> new()
    text: String
	init: func(=text){ 
        text each(|x| value add(x as UInt8)) 
        id = counter()
    }
    call: func -> String { "Class%d()" format(id) }
	compile: func -> String {
        ret := "Class%d: func -> Bool { \n" format(id)
        ret += "matchClass(%s)" format(text)
        ret + "\n}\n"
    }
	consumesInput: func -> Bool { true }
}

Action: class extends Node {
	text: String
	name: String
	rule: Node

	init: func(=text, actionCount: Int, =rule){
		name = "_%d_%s" format(actionCount, rule name)	
        id = counter()
		for(i in 0..text size - 1){
			if(text[i] == '$' && text[i+1] == '$'){
				text[i] = 'y'
				text[i+1] = 'y'
			}
		}
	}
    call: func -> String { "Action%d()" format(id) }
    compile: func -> String {
        "Action%d: func -> Bool { \n" format(id) + \
        "do(yyAction%s, \"yyAction%s\")\n" format(name, name) + \
        "\n}\n"
    }
	compileAction: func -> String {
        ret := "yyAction%s(text: String, thunk: Thunk, data: Pointer){\n" format(name)
        ret += text + "\n"
		ret + "}\n"
	}
	consumesInput: func -> Bool { false }
}

Predicate: class extends Node {
	text: String
	init: func(=text){
        id = counter()
    }
    call: func -> String { "Predicate%d()" format(id) }
	compile: func -> String{
        "Predicate%d: func -> Bool { \n" format(id) + \
        "text()\nif(!%s) return false" format(text) +\
        "true\n}\n"
    }
	consumesInput: func -> Bool { false }
}


/** 
 * Only one of value should be matched.
 * Implemented in `match .. case` pattern.
 */
Alternate: class extends Node {
	value := ArrayList<Node> new()
	init: func(e: Node){
        id = counter()
		if(e instanceOf?(Alternate)){ 
            value addAll(e as Alternate value)
			return
		}
		value add(e)
	}
	compile: func -> String {
        ret := "Altername%d: func -> Bool {\n return match(){\n" format(id)
        for(i in 0..value size){
            ret += "case %s => true" format(value[i] call())
        }
        ret + "case => false \n}"
    }
	consumesInput: func -> Int { 
		for(v in value) if(!v consumesInput()) return false
		true
	}
}

/**
 *  All values should be matched
 *  Any vaule return false will lead to a immeditae return
 *  implemented by if - else
 */
Sequence: class extends Node {
	value := ArrayList<Node> new()
	init: func(e: Node) {
        id = counter()
		if(e instanceOf?(Sequence)){ 
            value addAll(e as Sequence value)
		}
		value add(e)
	}
	append: func(e: Node) { value add(e) }
	compile: func -> String{
        ret := "Sequence%d: func -> Bool {\n" format(id)
        for(i in 0..value size){
            ret += "if( !%s ) return false" format(value call())
        }
        ret + "true\n}"
    }
    call: func -> String { "Sequence%d()" format(id) }
	consumesInput: func -> Int { 
		for(v in value) if(v consumesInput()) return true
		false
	}
}

PeekFor: class extends Node {
	element: Node
	init: func(=element){
        id = counter()
    }
	compile: func -> String
    call: func -> String { "PeekFor%d()" format(id) }
	consumesInput: func -> Int { false }
}

PeekNot: class extends Node {
	element: Node
	init: func(=element){
        id = counter()
    }

    call: func -> String { "PeekNot%d()" format(id) }
	compile: func -> String
	consumesInput: func -> Int { false }
}

Query: class extends Node {
	element: Node
	init: func(=element){
        id = counter()
    }

    call: func -> String { "Query%d()" format(id) }
	compile: func -> String
	consumesInput: func -> Int { false }
}

Star: class extends Node {
	element: Node
	init: func(=element){
        id = counter()
    }
    call: func -> String { "Star%d()" format(id) }
	compile: func -> String
	consumesInput: func -> Int { false }
}

Plus: class extends Node {
	element: Node
	init: func(=element)
	compile: func -> String{
        id = counter()
    }
    call: func -> String { "Plus%d()" format(id) }
	consumesInput: func -> Int { element consumesInput() }
}
